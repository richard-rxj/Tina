#!/usr/bin/env python# encoding: utf-8import tweepy #https://github.com/tweepy/tweepyimport csvimport timefrom pathlib import Pathimport pandas as pdfrom _datetime import datetime#Twitter API credentials, removed due to privacy concerns, needs to be replaced when use. Note these keys can be applied via any twitter accountconsumer_key = "4TROq0lwXWB5T7EWT5jVAf7Ii"consumer_secret = "1Qdvmoq4KiD51jlF0Gdg8NbpaqKj6GWxlu4FCCHwQd2kZaoNsd"access_key = "786201772096303108-pftfiLTyZ4vEs1QjrdGXKYHTtZzbEy2"access_secret = "67Lg1gvsxet7YOLmS96DqpRYLGYoXX3WbiYXUDWwBTvFF"keywords_list = ["acquisition", "articles", "asset sale", "auditor", "award", "blackout", "board", "certification", "conference call", "conferences", "credit agreement", "debt agreement", "debt restructure", "director interests", "dividends", "DRIPs", "drug trial", "earnings", "financial", "listing", "litigation", "merger", "management changes", "mineral updates", "option exercise", "own capital", "presentations", "private placements", "public offering", "ratings", "reorganization", "rights offering", "shareholder meeting", "shareholder resolution", "shareholder rights", "speech", "spin-off", "stock splits", "strategic alliance", "strike", "subsidiary dissolution", "sustainability", "tech report", "tender offer"]sleep_time = 100000def get_alltweets_by_user(api, screen_name):	all_tweets=[]	temp_tweets=[]	try:		temp_tweets.extend(api.user_timeline(screen_name = screen_name, count=200))	except tweepy.error.TweepError as e:		if e.api_code == 88:			loop_flag = True			while loop_flag:				print("Rate limit reached. Sleeping")				time.sleep(sleep_time)				try:					temp_tweets.extend(api.user_timeline(screen_name = screen_name, count=200))				except tweepy.TweepError as e2:					if e.api_code == 88: continue					else:	print(e)				loop_flag=False					while len(temp_tweets)>0:		oldest_id=temp_tweets[-1].id-1		all_tweets.extend(temp_tweets)		temp_tweets=[]		try:			#time.sleep(sleep_time)			temp_tweets.extend(api.user_timeline(screen_name = screen_name, count=200, max_id=oldest_id))		except tweepy.error.TweepError as e:			if e.api_code == 88:				loop_flag = True				while loop_flag:					print("Rate limit reached. Sleeping")					time.sleep(sleep_time)					try:						temp_tweets.extend(api.user_timeline(screen_name = screen_name, count=200, max_id=oldest_id))					except tweepy.TweepError as e2:						if e.api_code == 88: continue						else: print(e)					loop_flag=False	return all_tweetsdef get_tweets_info(twitter_account):#Twitter only allows access to all users in 'input_file_name' most recent tweets with this method# input_file_name: consists all informationa of users# output_file_name: output information to the given file name#authorize twitter, initialize tweepy	auth = tweepy.OAuthHandler(consumer_key, consumer_secret)	auth.set_access_token(access_key, access_secret)	api = tweepy.API(auth, wait_on_rate_limit=True, wait_on_rate_limit_notify=True)# get all tweets for the user with 'twitter_account'# check whether the user has a twitter account if not skip this row	row=[]	row.append(twitter_account)	if (twitter_account == "N/A") or (twitter_account==""):		row.append("invalid input")	screen_name = twitter_account	user_screen_name=None	try:		user_screen_name = api.get_user(screen_name)		#if user_screen_name.protected == True:		#	print("%s do not authorize to access his/her account" % screen_name)		#	row.append("do not authorize to access his/her account")	except tweepy.error.TweepError as e:		if e.api_code == 88:			loop_flag = True			while loop_flag:				print ("Rate limit reached. Sleeping")				time.sleep(sleep_time)				try:					user_screen_name = api.get_user(screen_name)				except tweepy.TweepError as e2:					if e2.api_code == 88: continue				loop_flag = False		elif e.api_code == 34:			print ("%s does not exist in twitter" % screen_name)			row.append("does not exist in twitter")		elif e.api_code == 63:			print ("%s 's user account is suspended" % screen_name)			row.append("user account is suspended")		else:			print (e)			row.append(str(e))	if user_screen_name is None:		row.append("user_screen_name is None")		return row	user_id=user_screen_name.id_str	num_followers = user_screen_name.followers_count	num_following = user_screen_name.friends_count	row.append(user_id)	row.append(num_followers)	row.append(num_following)	return rowdef read_info_from_csv(file_name, column_index, nrows=None):	result=[]	file_check=Path(file_name)	if(not file_check.exists()):		return result	with open(file_name, 'r') as inputFile:		reader = csv.reader(inputFile)		#next(reader)		cur_rows=0		for row in reader:			result.append(row[column_index])			cur_rows+=1			if nrows==cur_rows:				break	return resultdef to_csv(line, file_name, is_append):	mode='w'	if(is_append==True):		mode='a'	with open(file_name, mode, newline='') as outputFile:		writer = csv.writer(outputFile)		writer.writerow(line)if __name__ == '__main__':	output_file_name = "20180422_reply_account_result.csv"	input_file_name = "20180422_reply_account.csv"	tweet_column_index=0	input_user_infos=read_info_from_csv(input_file_name, tweet_column_index)	existing_user_infos_in_output=read_info_from_csv(output_file_name, tweet_column_index)	print("-------")	if(len(existing_user_infos_in_output)<=0):		to_csv(["twitter_account", "twitter_account_id", "num_followers", "num_following"], output_file_name, False)	total=len(input_user_infos)	index=len(existing_user_infos_in_output)	for user_info in input_user_infos:		#index=index+1		if user_info in existing_user_infos_in_output:			continue		index=index+1		print(str(total)+"-"+str(index)+"_"+user_info)		tweet_info=get_tweets_info(user_info)		to_csv(tweet_info, output_file_name, True)